{"ast":null,"code":"/*jshint node:true */\n\"use strict\";\n\nvar minimalDesc = ['h', 'min', 's', 'ms', 'μs', 'ns'];\nvar verboseDesc = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\nvar convert = [60 * 60, 60, 1, 1e6, 1e3, 1];\n\nmodule.exports = function (source, opts) {\n  var verbose, precise, i, spot, sourceAtStep, valAtStep, decimals, strAtStep, results, totalSeconds;\n  verbose = false;\n  precise = false;\n\n  if (opts) {\n    verbose = opts.verbose || false;\n    precise = opts.precise || false;\n  }\n\n  if (!Array.isArray(source) || source.length !== 2) {\n    return '';\n  }\n\n  if (typeof source[0] !== 'number' || typeof source[1] !== 'number') {\n    return '';\n  } // normalize source array due to changes in node v5.4+\n\n\n  if (source[1] < 0) {\n    totalSeconds = source[0] + source[1] / 1e9;\n    source[0] = parseInt(totalSeconds);\n    source[1] = parseFloat((totalSeconds % 1).toPrecision(9)) * 1e9;\n  }\n\n  results = ''; // foreach unit\n\n  for (i = 0; i < 6; i++) {\n    spot = i < 3 ? 0 : 1; // grabbing first or second spot in source array\n\n    sourceAtStep = source[spot];\n\n    if (i !== 3 && i !== 0) {\n      sourceAtStep = sourceAtStep % convert[i - 1]; // trim off previous portions\n    }\n\n    if (i === 2) {\n      sourceAtStep += source[1] / 1e9; // get partial seconds from other portion of the array\n    }\n\n    valAtStep = sourceAtStep / convert[i]; // val at this unit\n\n    if (valAtStep >= 1) {\n      if (verbose) {\n        valAtStep = Math.floor(valAtStep); // deal in whole units, subsequent laps will get the decimal portion\n      }\n\n      if (!precise) {\n        // don't fling too many decimals\n        decimals = valAtStep >= 10 ? 0 : 2;\n        strAtStep = valAtStep.toFixed(decimals);\n      } else {\n        strAtStep = valAtStep.toString();\n      }\n\n      if (strAtStep.indexOf('.') > -1 && strAtStep[strAtStep.length - 1] === '0') {\n        strAtStep = strAtStep.replace(/\\.?0+$/, ''); // remove trailing zeros\n      }\n\n      if (results) {\n        results += ' '; // append space if we have a previous value\n      }\n\n      results += strAtStep; // append the value\n      // append units\n\n      if (verbose) {\n        results += ' ' + verboseDesc[i];\n\n        if (strAtStep !== '1') {\n          results += 's';\n        }\n      } else {\n        results += ' ' + minimalDesc[i];\n      }\n\n      if (!verbose) {\n        break; // verbose gets as many groups as necessary, the rest get only one\n      }\n    }\n  }\n\n  return results;\n};","map":{"version":3,"sources":["/home/sebastian/Downloads/Donburi-master/node_modules/pretty-hrtime/index.js"],"names":["minimalDesc","verboseDesc","convert","module","exports","source","opts","verbose","precise","i","spot","sourceAtStep","valAtStep","decimals","strAtStep","results","totalSeconds","Array","isArray","length","parseInt","parseFloat","toPrecision","Math","floor","toFixed","toString","indexOf","replace"],"mappings":"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","sourcesContent":["/*jshint node:true */\r\n\r\n\"use strict\";\r\n\r\nvar minimalDesc = ['h', 'min', 's', 'ms', 'μs', 'ns'];\r\nvar verboseDesc = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\r\nvar convert = [60*60, 60, 1, 1e6, 1e3, 1];\r\n\r\nmodule.exports = function (source, opts) {\r\n\tvar verbose, precise, i, spot, sourceAtStep, valAtStep, decimals, strAtStep, results, totalSeconds;\r\n\r\n\tverbose = false;\r\n\tprecise = false;\r\n\tif (opts) {\r\n\t\tverbose = opts.verbose || false;\r\n\t\tprecise = opts.precise || false;\r\n\t}\r\n\r\n\tif (!Array.isArray(source) || source.length !== 2) {\r\n\t\treturn '';\r\n\t}\r\n\tif (typeof source[0] !== 'number' || typeof source[1] !== 'number') {\r\n\t\treturn '';\r\n\t}\r\n\r\n\t// normalize source array due to changes in node v5.4+\r\n\tif (source[1] < 0) {\r\n\t\ttotalSeconds = source[0] + source[1] / 1e9;\r\n\t\tsource[0] = parseInt(totalSeconds);\r\n\t\tsource[1] = parseFloat((totalSeconds % 1).toPrecision(9)) * 1e9;\r\n\t}\r\n\r\n\tresults = '';\r\n\r\n\t// foreach unit\r\n\tfor (i = 0; i < 6; i++) {\r\n\t\tspot = i < 3 ? 0 : 1; // grabbing first or second spot in source array\r\n\t\tsourceAtStep = source[spot];\r\n\t\tif (i !== 3 && i !== 0) {\r\n\t\t\tsourceAtStep = sourceAtStep % convert[i-1]; // trim off previous portions\r\n\t\t}\r\n\t\tif (i === 2) {\r\n\t\t\tsourceAtStep += source[1]/1e9; // get partial seconds from other portion of the array\r\n\t\t}\r\n\t\tvalAtStep = sourceAtStep / convert[i]; // val at this unit\r\n\t\tif (valAtStep >= 1) {\r\n\t\t\tif (verbose) {\r\n\t\t\t\tvalAtStep = Math.floor(valAtStep); // deal in whole units, subsequent laps will get the decimal portion\r\n\t\t\t}\r\n\t\t\tif (!precise) {\r\n\t\t\t\t// don't fling too many decimals\r\n\t\t\t\tdecimals = valAtStep >= 10 ? 0 : 2;\r\n\t\t\t\tstrAtStep = valAtStep.toFixed(decimals);\r\n\t\t\t} else {\r\n\t\t\t\tstrAtStep = valAtStep.toString();\r\n\t\t\t}\r\n\t\t\tif (strAtStep.indexOf('.') > -1 && strAtStep[strAtStep.length-1] === '0') {\r\n\t\t\t\tstrAtStep = strAtStep.replace(/\\.?0+$/,''); // remove trailing zeros\r\n\t\t\t}\r\n\t\t\tif (results) {\r\n\t\t\t\tresults += ' '; // append space if we have a previous value\r\n\t\t\t}\r\n\t\t\tresults += strAtStep; // append the value\r\n\t\t\t// append units\r\n\t\t\tif (verbose) {\r\n\t\t\t\tresults += ' '+verboseDesc[i];\r\n\t\t\t\tif (strAtStep !== '1') {\r\n\t\t\t\t\tresults += 's';\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tresults += ' '+minimalDesc[i];\r\n\t\t\t}\r\n\t\t\tif (!verbose) {\r\n\t\t\t\tbreak; // verbose gets as many groups as necessary, the rest get only one\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}