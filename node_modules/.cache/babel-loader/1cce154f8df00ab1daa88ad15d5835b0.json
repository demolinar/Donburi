{"ast":null,"code":"class Node {\n  constructor(value) {\n    this.data = value;\n    this.left = this.right = null;\n  }\n\n}\n\nclass BST {\n  constructor() {\n    this.root = null;\n  }\n\n  minValue(node) {\n    let current = node;\n\n    while (current && current.left != null) {\n      current = current.left;\n    }\n\n    return current;\n  }\n\n  maxValue(node) {\n    let current = node;\n\n    while (current && current.right != null) {\n      current = current.right;\n    }\n\n    return current;\n  }\n\n  delete(root, key) {\n    if (root == null) {\n      return root;\n    }\n\n    if (key < root.data) {\n      root.left = this.delete(root.left, key);\n    } else if (key > root.data) {\n      root.right = this.delete(root.right, key);\n    } else {\n      if (root.left === null) {\n        return root.right;\n      } else if (root.right == null) {\n        return root.left;\n      }\n\n      root.data = this.minValue(root.right);\n      root.right = this.delete(root.right, root.data);\n    }\n\n    return root;\n  }\n\n  insert(data) {\n    let newNode = new Node(data);\n    if (this.root === null) this.root = newNode;else this.insertNode(this.root, newNode);\n  }\n\n  insertNode(node, newNode) {\n    // if the data is less than the node\n    // data move left of the tree\n    if (newNode.data < node.data) {\n      // if left is null insert node here\n      if (node.left === null) node.left = newNode;else // if left is not null recur until\n        // null is found\n        this.insertNode(node.left, newNode);\n    } // if the data is more than the node\n    // data move right of the tree\n    else {\n        // if right is null insert node here\n        if (node.right === null) node.right = newNode;else // if right is not null recur until\n          // null is found\n          this.insertNode(node.right, newNode);\n      }\n  }\n\n  inorder(root) {\n    if (!root) {\n      return;\n    }\n\n    this.inorder(root.left);\n    console.log(root.data);\n    this.inorder(root.right);\n  }\n\n  search(root, key) {\n    if (root === null || root.data === key) return root;\n    if (root.data > key) return this.search(root.left, key);\n    return this.search(root.right, key);\n  }\n\n  toArray(node) {\n    let result = [];\n\n    if (node.left != null) {\n      result.push(this.toArray(node.left));\n    }\n\n    if (node.right != null) {\n      result.push(this.toArray(node.right));\n    }\n\n    result.push(node.data);\n    return result;\n  }\n\n}\n\nexport default BST;","map":{"version":3,"sources":["/home/sebastian/Downloads/Donburi-master/src/components/DataStructures/BST.js"],"names":["Node","constructor","value","data","left","right","BST","root","minValue","node","current","maxValue","delete","key","insert","newNode","insertNode","inorder","console","log","search","toArray","result","push"],"mappings":"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","sourcesContent":["class Node{\n\n    constructor(value) {\n        this.data = value;\n        this.left = this.right = null;\n    }\n\n}\n\nclass BST {\n\n    constructor() {\n        this.root = null;\n    }\n\n    minValue(node) {\n        let current = node;\n        while (current && current.left != null){\n            current = current.left;\n        }\n        return current;\n    }\n\n    maxValue(node) {\n        let current = node;\n        while (current && current.right != null){\n            current = current.right;\n        }\n        return current;\n    }\n\n    delete(root, key) {\n        if (root == null) {\n            return root;\n        }\n\n        if (key < root.data) {\n            root.left = this.delete(root.left, key);\n        } else if (key > root.data) {\n            root.right = this.delete(root.right, key);\n        } else {\n            if (root.left === null) {\n                return root.right;\n            } else if (root.right == null) {\n                return root.left;\n            }\n            root.data = this.minValue(root.right);\n            root.right = this.delete(root.right, root.data);\n        }\n        return root;\n    }\n\n    insert(data) {\n        let newNode = new Node(data);\n\n        if(this.root === null)\n            this.root = newNode;\n        else\n            this.insertNode(this.root, newNode);\n    }\n\n    insertNode(node, newNode) {\n        // if the data is less than the node\n        // data move left of the tree\n        if(newNode.data < node.data)\n        {\n            // if left is null insert node here\n            if(node.left === null)\n                node.left = newNode;\n            else\n\n                // if left is not null recur until\n                // null is found\n                this.insertNode(node.left, newNode);\n        }\n\n            // if the data is more than the node\n        // data move right of the tree\n        else\n        {\n            // if right is null insert node here\n            if(node.right === null)\n                node.right = newNode;\n            else\n\n                // if right is not null recur until\n                // null is found\n                this.insertNode(node.right,newNode);\n        }\n    }\n\n    inorder(root) {\n        if (!root) {\n            return;\n        }\n        this.inorder(root.left);\n        console.log(root.data);\n        this.inorder(root.right);\n    }\n\n    search(root, key) {\n        if (root===null || root.data===key)\n            return root;\n        if (root.data > key)\n            return this.search(root.left, key);\n        return this.search(root.right, key);\n    }\n\n    toArray(node) {\n        let result = [];\n        if (node.left != null) {\n            result.push(this.toArray(node.left));\n        }\n    \n        if (node.right != null) {\n            result.push(this.toArray(node.right));\n        }\n        result.push(node.data);\n        return result;\n    }\n\n}\n\nexport default BST;"]},"metadata":{},"sourceType":"module"}